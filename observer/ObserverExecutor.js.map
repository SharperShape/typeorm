{"version":3,"sources":["../../src/observer/ObserverExecutor.ts"],"names":[],"mappings":";;;AACA,oDAA+C;AAC/C,gGAA2F;AAG3F;;GAEG;AACH,MAAa,gBAAgB;IAEzB,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,YAAoB,SAA0B;QAA1B,cAAS,GAAT,SAAS,CAAiB;IAC9C,CAAC;IAED,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;OAEG;IACH,KAAK,CAAC,OAAO;QACT,KAAK,IAAI,QAAQ,IAAI,IAAI,CAAC,SAAS,EAAE;YAEjC,IAAI,QAAQ,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;gBAClC,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;gBACvC,QAAQ,CAAC,YAAY,GAAG,EAAE,CAAC;aAC9B;YAED,IAAI,QAAQ,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;gBAClC,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;gBACvC,QAAQ,CAAC,YAAY,GAAG,EAAE,CAAC;aAC9B;YAED,IAAI,QAAQ,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;gBAClC,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;gBACvC,QAAQ,CAAC,YAAY,GAAG,EAAE,CAAC;aAC9B;SACJ;IACL,CAAC;IAED,4EAA4E;IAC5E,kBAAkB;IAClB,4EAA4E;IAEpE,KAAK,CAAC,iBAAiB,CAAC,QAAuB;QAEnD,8EAA8E;QAC9E,oEAAoE;QACpE,IAAI,QAAQ,CAAC,IAAI,KAAK,MAAM,EAAE;YAC1B,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAC3H,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC,gBAAgB,CAAC,CAAC;gBAC9F,IAAI,WAAW,EAAE;oBACb,QAAQ,CAAC,gBAAgB,GAAG,WAAW,CAAC;oBACxC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;iBACjE;YACL,CAAC,CAAC,CAAC;SAEN;aAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,SAAS,EAAE;YACpC,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;gBAC5H,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE;oBACrC,IAAI,MAAM,KAAK,SAAS,IAAI,QAAQ,CAAC,cAAc,KAAK,SAAS,EAAE;wBAC/D,OAAO;qBACV;oBACD,QAAQ,CAAC,cAAc,GAAG,MAAM,CAAC;oBACjC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;oBAC5D,OAAO;iBACV;gBACD,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC;gBAC9F,IAAI,WAAW,EAAE;oBACb,QAAQ,CAAC,cAAc,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBACzC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;iBAC/D;YACL,CAAC,CAAC,CAAC;SAEN;aAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,cAAc,EAAE;YACzC,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE,EAAE;gBAC9I,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC,gBAAgB,CAAC,CAAC;gBAC9F,IAAI,WAAW,IAAI,KAAK,KAAK,QAAQ,CAAC,aAAa,EAAE;oBACjD,IAAI,WAAW;wBACX,QAAQ,CAAC,gBAAgB,GAAG,WAAW,CAAC;oBAC5C,IAAI,KAAK,KAAK,QAAQ,CAAC,aAAa;wBAChC,QAAQ,CAAC,aAAa,GAAG,KAAK,CAAC;oBAEnC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,gBAAgB,EAAE,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC;iBAC3F;YACL,CAAC,CAAC,CAAC;SAEN;aAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,EAAE;YAClC,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;gBAC/I,IAAI,KAAK,KAAK,QAAQ,CAAC,aAAa,EAAE;oBAClC,QAAQ,CAAC,aAAa,GAAG,KAAK,CAAC;oBAC/B,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;iBAC9D;YACL,CAAC,CAAC,CAAC;SACN;IACL,CAAC;IAEO,YAAY,CAAC,QAAwB,EAAE,QAAyB,EAAE,gBAAiC;QAEvG,kFAAkF;QAClF,gFAAgF;QAChF,IAAI,SAAS,GAAG,KAAK,CAAC;QACtB,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;YAC7B,MAAM,oBAAoB,GAAG,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE;gBAChE,OAAO,QAAQ,CAAC,eAAe,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;YAC5D,CAAC,CAAC,CAAC;YACH,IAAI,oBAAoB,EAAE;gBACtB,OAAO,oBAAoB,CAAC;aAC/B;iBAAM;gBACH,SAAS,GAAG,IAAI,CAAC;gBACjB,OAAO,MAAM,CAAC;aACjB;QACL,CAAC,CAAC,CAAC;QAEH,6CAA6C;QAC7C,IAAI,SAAS;YACT,OAAO,QAAQ,CAAC;QAEpB,OAAO,SAAS,CAAC;IACrB,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAAC,QAAuB;QAEnD,+EAA+E;QAC/E,6EAA6E;QAC7E,kCAAkC;QAClC,MAAM,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC;QACrC,MAAM,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;YACrC,OAAO,KAAK,CAAC,MAAM,IAAI,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QACjE,CAAC,CAAC,CAAC;QACH,IAAI,WAAW,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,EAAE;YAC1C,MAAM,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;YAC1F,IAAI,mBAAmB,KAAK,KAAK;gBAC7B,OAAO;SACd;QAED,IAAI,QAAQ,CAAC,IAAI,KAAK,MAAM,EAAE;YAC1B,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO;iBAC5B,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC;iBAC5E,IAAI,CAAC,QAAQ,CAAC,EAAE;gBACb,MAAM,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;gBAC9E,IAAI,UAAU,IAAI,QAAQ,CAAC,MAAM,KAAK,QAAQ,CAAC,gBAAgB,CAAC,MAAM,EAAE;oBACpE,QAAQ,CAAC,gBAAgB,GAAG,QAAQ,CAAC;oBACrC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;iBACjE;YACL,CAAC,CAAC,CAAC;SAEV;aAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,SAAS,EAAE;YACpC,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO;iBAC5B,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC;iBAC/E,IAAI,CAAC,MAAM,CAAC,EAAE;gBACX,IAAI,CAAC,MAAM,EAAE;oBACT,QAAQ,CAAC,cAAc,GAAG,SAAS,CAAC;oBACpC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;iBAC/D;qBAAM,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,EAAE;oBAC1C,QAAQ,CAAC,cAAc,GAAG,MAAM,CAAC;oBACjC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;iBAC/D;YACL,CAAC,CAAC,CAAC;SAEV;aAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,cAAc,EAAE;YACzC,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO;iBAC5B,YAAY,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC;iBACpF,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE,EAAE;gBAExB,MAAM,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;gBAC9E,IAAI,UAAU,IAAI,KAAK,KAAK,QAAQ,CAAC,aAAa,IAAI,QAAQ,CAAC,MAAM,KAAK,QAAQ,CAAC,gBAAgB,CAAC,MAAM,EAAE;oBACxG,IAAI,UAAU,IAAI,QAAQ,CAAC,MAAM,KAAK,QAAQ,CAAC,gBAAgB,CAAC,MAAM;wBAClE,QAAQ,CAAC,gBAAgB,GAAG,QAAQ,CAAC;oBACzC,IAAI,KAAK,KAAK,QAAQ,CAAC,aAAa;wBAChC,QAAQ,CAAC,aAAa,GAAG,KAAK,CAAC;oBAEnC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,gBAAgB,EAAE,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC;iBAC3F;YACL,CAAC,CAAC,CAAC;SACV;aAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,EAAE;YAClC,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO;iBAC5B,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC;iBAC7E,IAAI,CAAC,KAAK,CAAC,EAAE;gBACV,IAAI,KAAK,KAAK,QAAQ,CAAC,aAAa,EAAE;oBAClC,QAAQ,CAAC,aAAa,GAAG,KAAK,CAAC;oBAC/B,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;iBAC9D;YACL,CAAC,CAAC,CAAC;SACV;IACL,CAAC;IAEO,UAAU,CAAC,QAAuB,EAAE,MAAqB;QAE7D,IAAI,cAAuC,CAAC;QAC5C,IAAI,QAAQ,CAAC,IAAI,KAAK,MAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,cAAc,EAAE;YAC9D,cAAc,GAAG,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE;gBAC7D,OAAO,QAAQ,CAAC,QAAQ,CAAC,eAAe,CAAC,cAAc,EAAE,MAAM,CAAC,CAAC;YACrE,CAAC,CAAC,CAAC;SACN;aAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,SAAS,EAAE;YACpC,cAAc,GAAG,QAAQ,CAAC,cAAc,CAAC;SAC5C;QAED,yFAAyF;QACzF,+CAA+C;QAC/C,IAAI,CAAC,cAAc;YACf,OAAO,IAAI,CAAC;QAEhB,MAAM,OAAO,GAAG,IAAI,iBAAO,CAAC;YACxB,QAAQ,EAAE,QAAQ,CAAC,QAAQ;YAC3B,MAAM,EAAE,MAAM;YACd,cAAc,EAAE,cAAc;SACjC,CAAC,CAAC;QAEH,yCAAyC;QACzC,IAAI,6DAA6B,EAAE,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;QACvD,OAAO,OAAO,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;IACzC,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAAC,QAAuB;QAEnD,4CAA4C;QAC5C,8DAA8D;QAC9D,iFAAiF;QAEjF,MAAM,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC;QACrC,MAAM,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAC1D,IAAI,WAAW,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,EAAE;YAC1C,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBACnB,IAAI,QAAQ,CAAC,IAAI,KAAK,MAAM,EAAE;oBAC1B,MAAM,kBAAkB,GAAG,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;wBAC/D,OAAO,QAAQ,CAAC,QAAQ,CAAC,eAAe,CAAC,MAAM,EAAE,QAAQ,CAAC,QAAQ,CAAC,iBAAiB,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAC1G,CAAC,CAAC,CAAC;oBACH,IAAI,kBAAkB,EAAE;wBACpB,QAAQ,CAAC,gBAAgB,CAAC,MAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC,CAAC;wBAC3F,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;qBACjE;iBAEJ;qBAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,cAAc,EAAE;oBACzC,MAAM,0BAA0B,GAAG,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;wBACvE,OAAO,QAAQ,CAAC,QAAQ,CAAC,eAAe,CAAC,MAAM,EAAE,QAAQ,CAAC,QAAQ,CAAC,iBAAiB,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAC1G,CAAC,CAAC,CAAC;oBACH,IAAI,0BAA0B,EAAE;wBAC5B,QAAQ,CAAC,gBAAgB,CAAC,MAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC,0BAA0B,CAAC,EAAE,CAAC,CAAC,CAAC;wBACnG,QAAQ,CAAC,aAAa,EAAE,CAAC;wBACzB,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,gBAAgB,EAAE,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC;qBAE3F;iBAEJ;qBAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,SAAS,EAAE;oBACpC,IAAI,QAAQ,CAAC,cAAc,EAAE;wBACzB,IAAI,QAAQ,CAAC,QAAQ,CAAC,eAAe,CAAC,QAAQ,CAAC,cAAc,EAAE,QAAQ,CAAC,QAAQ,CAAC,iBAAiB,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE;4BACjH,QAAQ,CAAC,cAAc,GAAG,SAAS,CAAC;4BACpC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;yBAC/D;qBACJ;iBACJ;YACL,CAAC,CAAC,CAAC;YACH,OAAO;SAEV;aAAM;YAEH,IAAI,QAAQ,CAAC,IAAI,KAAK,MAAM,EAAE;gBAC1B,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,aAAa;oBAC5D,OAAO;gBAEX,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;oBAE3H,6CAA6C;oBAC7C,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE;wBACrC,QAAQ,CAAC,gBAAgB,GAAG,QAAQ,CAAC;wBACrC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;qBACjE;gBACL,CAAC,CAAC,CAAC;aAEN;iBAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,cAAc,EAAE;gBACzC,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,aAAa;oBAC5D,OAAO;gBAEX,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE,EAAE;oBAE9I,6CAA6C;oBAC7C,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,QAAQ,CAAC,IAAI,QAAQ,CAAC,aAAa,KAAK,KAAK,EAAE;wBACzE,QAAQ,CAAC,gBAAgB,GAAG,QAAQ,CAAC;wBACrC,QAAQ,CAAC,aAAa,GAAG,KAAK,CAAC;wBAC/B,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,gBAAgB,EAAE,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC;qBAC3F;gBACL,CAAC,CAAC,CAAC;aAEN;iBAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,SAAS,EAAE;gBACpC,IAAI,CAAC,QAAQ,CAAC,cAAc;oBACxB,OAAO;gBAEX,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAA2B,EAAE,QAAQ,CAAC,OAAc,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;oBAC5H,IAAI,CAAC,MAAM,EAAE;wBACT,QAAQ,CAAC,cAAc,GAAG,SAAS,CAAC;wBACpC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;wBAC5D,OAAO;qBACV;oBAED,6CAA6C;oBAC7C,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE;wBACrC,QAAQ,CAAC,cAAc,GAAG,SAAS,CAAC;wBACpC,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;qBAC/D;gBACL,CAAC,CAAC,CAAC;aAEN;iBAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,EAAE;gBAClC,IAAI,CAAC,QAAQ,CAAC,aAAa;oBACvB,OAAO;gBAEX,MAAM,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAa,EAAE,QAAQ,CAAC,OAAc,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;oBACjI,IAAI,QAAQ,CAAC,aAAa,KAAK,KAAK,EAAE;wBAClC,QAAQ,CAAC,aAAa,GAAG,KAAK,CAAC;wBAC/B,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;qBAC9D;gBACL,CAAC,CAAC,CAAC;aACN;SAEJ;IACL,CAAC;IAEO,UAAU,CAAC,QAAuB,EAAE,QAAyB;QACjE,IAAI,SAAS,GAAG,KAAK,CAAC;QAEtB,IAAI,QAAQ,CAAC,IAAI,KAAK,MAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,cAAc,EAAE;YAC9D,QAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE;gBAC/C,MAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;oBAClC,OAAO,QAAQ,CAAC,QAAQ,CAAC,eAAe,CAAC,cAAc,EAAE,MAAM,CAAC,CAAC;gBACrE,CAAC,CAAC,CAAC;gBAEH,IAAI,CAAC,MAAM,EAAE;oBACT,SAAS,GAAG,IAAI,CAAC;oBACjB,QAAQ,CAAC,gBAAgB,CAAC,MAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,CAAC;iBAC1F;YACL,CAAC,CAAC,CAAC;SACN;aAAM,IAAI,QAAQ,CAAC,IAAI,KAAK,SAAS,EAAE;YACpC,IAAI,CAAC,QAAQ,CAAC,cAAc;gBACxB,OAAO,KAAK,CAAC;YAEjB,MAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;gBAClC,OAAO,QAAQ,CAAC,QAAQ,CAAC,eAAe,CAAC,QAAQ,CAAC,cAAe,EAAE,MAAM,CAAC,CAAC;YAC/E,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,MAAM;gBACP,OAAO,KAAK,CAAC;SACpB;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;CAEJ;AArVD,4CAqVC","file":"ObserverExecutor.js","sourcesContent":["import {EntityMetadata, ObjectLiteral, EntityTarget} from \"..\";\nimport {Subject} from \"../persistence/Subject\";\nimport {SubjectChangedColumnsComputer} from \"../persistence/SubjectChangedColumnsComputer\";\nimport {QueryObserver} from \"./QueryObserver\";\n\n/**\n * Executes all given observers.\n */\nexport class ObserverExecutor {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private observers: QueryObserver[]) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes given observers.\n     */\n    async execute(): Promise<void> {\n        for (let observer of this.observers) {\n\n            if (observer.insertEvents.length > 0) {\n                await this.handleInsertEvent(observer);\n                observer.insertEvents = [];\n            }\n\n            if (observer.updateEvents.length > 0) {\n                await this.handleUpdateEvent(observer);\n                observer.updateEvents = [];\n            }\n\n            if (observer.removeEvents.length > 0) {\n                await this.handleRemoveEvent(observer);\n                observer.removeEvents = [];\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private async handleInsertEvent(observer: QueryObserver) {\n\n        // if something new is inserted - we never know if that matches original query\n        // so we execute query again and emit event if we find something new\n        if (observer.type === \"find\") {\n            await observer.connection.manager.find(observer.metadata.target as EntityTarget<any>, observer.options as any).then(entities => {\n                const newEntities = this.findInserted(observer.metadata, entities, observer.lastEmitEntities);\n                if (newEntities) {\n                    observer.lastEmitEntities = newEntities;\n                    observer.subscriptionObserver.next(observer.lastEmitEntities);\n                }\n            });\n\n        } else if (observer.type === \"findOne\") {\n            await observer.connection.manager.findOne(observer.metadata.target as EntityTarget<any>, observer.options as any).then(entity => {\n                if (!entity || !observer.lastEmitEntity) {\n                    if (entity === undefined && observer.lastEmitEntity === undefined) {\n                        return;\n                    }\n                    observer.lastEmitEntity = entity;\n                    observer.subscriptionObserver.next(observer.lastEmitEntity);\n                    return;\n                }\n                const newEntities = this.findInserted(observer.metadata, [entity], [observer.lastEmitEntity]);\n                if (newEntities) {\n                    observer.lastEmitEntity = newEntities[0];\n                    observer.subscriptionObserver.next(observer.lastEmitEntity);\n                }\n            });\n\n        } else if (observer.type === \"findAndCount\") {\n            await observer.connection.manager.findAndCount(observer.metadata.target as EntityTarget<any>, observer.options as any).then(([entities, count]) => {\n                const newEntities = this.findInserted(observer.metadata, entities, observer.lastEmitEntities);\n                if (newEntities || count !== observer.lastEmitCount) {\n                    if (newEntities)\n                        observer.lastEmitEntities = newEntities;\n                    if (count !== observer.lastEmitCount)\n                        observer.lastEmitCount = count;\n\n                    observer.subscriptionObserver.next([observer.lastEmitEntities, observer.lastEmitCount]);\n                }\n            });\n\n        } else if (observer.type === \"count\") {\n            await observer.connection.manager.count(observer.metadata.target as EntityTarget<any>, observer.options as any, { observers: false }).then(count => {\n                if (count !== observer.lastEmitCount) {\n                    observer.lastEmitCount = count;\n                    observer.subscriptionObserver.next(observer.lastEmitCount);\n                }\n            });\n        }\n    }\n\n    private findInserted(metadata: EntityMetadata, entities: ObjectLiteral[], lastEmitEntities: ObjectLiteral[]) {\n\n        // to make sure we won't have instance mess we try to return array of NEW entities\n        // in the same NEW order we have, but with OLD instances that we can find in the\n        let hasChange = false;\n        entities = entities.map(entity => {\n            const sameEntityInPrevious = lastEmitEntities.find(previousEntity => {\n                return metadata.compareEntities(entity, previousEntity);\n            });\n            if (sameEntityInPrevious) {\n                return sameEntityInPrevious;\n            } else {\n                hasChange = true;\n                return entity;\n            }\n        });\n\n        // if we have any new entity emit a new event\n        if (hasChange)\n            return entities;\n\n        return undefined;\n    }\n\n    private async handleUpdateEvent(observer: QueryObserver) {\n\n        // if something is updated - we check if its any entity of the queried entities\n        // and if it is, we compare properties to understand if something was changed\n        // and emit event if something was\n        const events = observer.updateEvents;\n        const hasEntities = events.every(event => {\n            return event.entity && observer.metadata.hasId(event.entity);\n        });\n        if (hasEntities && observer.type !== \"count\") {\n            const hasAnyEntityChanges = events.some(event => this.hasChanges(observer, event.entity));\n            if (hasAnyEntityChanges === false)\n                return;\n        }\n\n        if (observer.type === \"find\") {\n            await observer.connection.manager\n                .find(observer.metadata.target as EntityTarget<any>, observer.options as any)\n                .then(entities => {\n                    const hasChanges = entities.some(entity => this.hasChanges(observer, entity));\n                    if (hasChanges || entities.length !== observer.lastEmitEntities.length) {\n                        observer.lastEmitEntities = entities;\n                        observer.subscriptionObserver.next(observer.lastEmitEntities);\n                    }\n                });\n\n        } else if (observer.type === \"findOne\") {\n            await observer.connection.manager\n                .findOne(observer.metadata.target as EntityTarget<any>, observer.options as any)\n                .then(entity => {\n                    if (!entity) {\n                        observer.lastEmitEntity = undefined;\n                        observer.subscriptionObserver.next(observer.lastEmitEntity);\n                    } else if (this.hasChanges(observer, entity)) {\n                        observer.lastEmitEntity = entity;\n                        observer.subscriptionObserver.next(observer.lastEmitEntity);\n                    }\n                });\n\n        } else if (observer.type === \"findAndCount\") {\n            await observer.connection.manager\n                .findAndCount(observer.metadata.target as EntityTarget<any>, observer.options as any)\n                .then(([entities, count]) => {\n\n                    const hasChanges = entities.some(entity => this.hasChanges(observer, entity));\n                    if (hasChanges || count !== observer.lastEmitCount || entities.length !== observer.lastEmitEntities.length) {\n                        if (hasChanges || entities.length !== observer.lastEmitEntities.length)\n                            observer.lastEmitEntities = entities;\n                        if (count !== observer.lastEmitCount)\n                            observer.lastEmitCount = count;\n\n                        observer.subscriptionObserver.next([observer.lastEmitEntities, observer.lastEmitCount]);\n                    }\n                });\n        } else if (observer.type === \"count\") {\n            await observer.connection.manager\n                .count(observer.metadata.target as EntityTarget<any>, observer.options as any)\n                .then(count => {\n                    if (count !== observer.lastEmitCount) {\n                        observer.lastEmitCount = count;\n                        observer.subscriptionObserver.next(observer.lastEmitCount);\n                    }\n                });\n        }\n    }\n\n    private hasChanges(observer: QueryObserver, entity: ObjectLiteral) {\n\n        let previousEntity: ObjectLiteral|undefined;\n        if (observer.type === \"find\" || observer.type === \"findAndCount\") {\n            previousEntity = observer.lastEmitEntities.find(previousEntity => {\n                return observer.metadata.compareEntities(previousEntity, entity);\n            });\n        } else if (observer.type === \"findOne\") {\n            previousEntity = observer.lastEmitEntity;\n        }\n\n        // if previous entity is not set it probably means it was failed off the condition first,\n        // then update causes it to match the condition\n        if (!previousEntity)\n            return true;\n\n        const subject = new Subject({\n            metadata: observer.metadata,\n            entity: entity,\n            databaseEntity: previousEntity,\n        });\n\n        // find changed columns - if we have them\n        new SubjectChangedColumnsComputer().compute([subject]);\n        return subject.changeMaps.length > 0;\n    }\n\n    private async handleRemoveEvent(observer: QueryObserver) {\n\n        // if something is removed we have to check:\n        // - if entity with id was removed we check if its that entity\n        // - if entity by query was removed we do execute original query again and differ\n\n        const events = observer.removeEvents;\n        const allEntities = events.every(event => event.entityId);\n        if (allEntities && observer.type !== \"count\") {\n            events.forEach(event => {\n                if (observer.type === \"find\") {\n                    const findPreviousEntity = observer.lastEmitEntities.find(entity => {\n                        return observer.metadata.compareEntities(entity, observer.metadata.ensureEntityIdMap(event.entityId));\n                    });\n                    if (findPreviousEntity) {\n                        observer.lastEmitEntities.splice(observer.lastEmitEntities.indexOf(findPreviousEntity), 1);\n                        observer.subscriptionObserver.next(observer.lastEmitEntities);\n                    }\n\n                } else if (observer.type === \"findAndCount\") {\n                    const findAndCountPreviousEntity = observer.lastEmitEntities.find(entity => {\n                        return observer.metadata.compareEntities(entity, observer.metadata.ensureEntityIdMap(event.entityId));\n                    });\n                    if (findAndCountPreviousEntity) {\n                        observer.lastEmitEntities.splice(observer.lastEmitEntities.indexOf(findAndCountPreviousEntity), 1);\n                        observer.lastEmitCount--;\n                        observer.subscriptionObserver.next([observer.lastEmitEntities, observer.lastEmitCount]);\n\n                    }\n\n                } else if (observer.type === \"findOne\") {\n                    if (observer.lastEmitEntity) {\n                        if (observer.metadata.compareEntities(observer.lastEmitEntity, observer.metadata.ensureEntityIdMap(event.entityId))) {\n                            observer.lastEmitEntity = undefined;\n                            observer.subscriptionObserver.next(observer.lastEmitEntity);\n                        }\n                    }\n                }\n            });\n            return;\n\n        } else {\n\n            if (observer.type === \"find\") {\n                if (!observer.lastEmitEntities.length && !observer.lastEmitCount)\n                    return;\n\n                await observer.connection.manager.find(observer.metadata.target as EntityTarget<any>, observer.options as any).then(entities => {\n\n                    // if we have any new entity emit a new event\n                    if (this.hasRemoved(observer, entities)) {\n                        observer.lastEmitEntities = entities;\n                        observer.subscriptionObserver.next(observer.lastEmitEntities);\n                    }\n                });\n\n            } else if (observer.type === \"findAndCount\") {\n                if (!observer.lastEmitEntities.length && !observer.lastEmitCount)\n                    return;\n\n                await observer.connection.manager.findAndCount(observer.metadata.target as EntityTarget<any>, observer.options as any).then(([entities, count]) => {\n\n                    // if we have any new entity emit a new event\n                    if (this.hasRemoved(observer, entities) || observer.lastEmitCount !== count) {\n                        observer.lastEmitEntities = entities;\n                        observer.lastEmitCount = count;\n                        observer.subscriptionObserver.next([observer.lastEmitEntities, observer.lastEmitCount]);\n                    }\n                });\n\n            } else if (observer.type === \"findOne\") {\n                if (!observer.lastEmitEntity)\n                    return;\n\n                await observer.connection.manager.findOne(observer.metadata.target as EntityTarget<any>, observer.options as any).then(entity => {\n                    if (!entity) {\n                        observer.lastEmitEntity = undefined;\n                        observer.subscriptionObserver.next(observer.lastEmitEntity);\n                        return;\n                    }\n\n                    // if we have any new entity emit a new event\n                    if (this.hasRemoved(observer, [entity])) {\n                        observer.lastEmitEntity = undefined;\n                        observer.subscriptionObserver.next(observer.lastEmitEntity);\n                    }\n                });\n\n            } else if (observer.type === \"count\") {\n                if (!observer.lastEmitCount)\n                    return;\n\n                await observer.connection.manager.count(observer.metadata.target as any, observer.options as any, { observers: false }).then(count => {\n                    if (observer.lastEmitCount !== count) {\n                        observer.lastEmitCount = count;\n                        observer.subscriptionObserver.next(observer.lastEmitCount);\n                    }\n                });\n            }\n\n        }\n    }\n\n    private hasRemoved(observer: QueryObserver, entities: ObjectLiteral[]) {\n        let hasChange = false;\n\n        if (observer.type === \"find\" || observer.type === \"findAndCount\") {\n            observer.lastEmitEntities.forEach(previousEntity => {\n                const entity = entities.find(entity => {\n                    return observer.metadata.compareEntities(previousEntity, entity);\n                });\n\n                if (!entity) {\n                    hasChange = true;\n                    observer.lastEmitEntities.splice(observer.lastEmitEntities.indexOf(previousEntity), 1);\n                }\n            });\n        } else if (observer.type === \"findOne\") {\n            if (!observer.lastEmitEntity)\n                return false;\n\n            const entity = entities.find(entity => {\n                return observer.metadata.compareEntities(observer.lastEmitEntity!, entity);\n            });\n            if (!entity)\n                return false;\n        }\n\n        return hasChange;\n    }\n\n}\n"],"sourceRoot":".."}