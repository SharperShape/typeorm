{"version":3,"sources":["../browser/src/query-builder/relation-count/RelationCountLoader.ts"],"names":[],"mappings":"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","file":"RelationCountLoader.js","sourcesContent":["import {ColumnMetadata} from \"../../metadata/ColumnMetadata\";\nimport {Connection} from \"../../connection/Connection\";\nimport {RelationCountAttribute} from \"./RelationCountAttribute\";\nimport {RelationCountLoadResult} from \"./RelationCountLoadResult\";\nimport {QueryRunner} from \"../../query-runner/QueryRunner\";\n\nexport class RelationCountLoader {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection,\n                protected queryRunner: QueryRunner|undefined,\n                protected relationCountAttributes: RelationCountAttribute[]) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationCountLoadResult[]> {\n\n        const onlyUnique = (value: any, index: number, self: any) => {\n            return self.indexOf(value) === index;\n        };\n\n        const promises = this.relationCountAttributes.map(async relationCountAttr => {\n\n            if (relationCountAttr.relation.isOneToMany) {\n                // example: Post and Category\n                // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n                // we expect it to load array of post ids\n\n                // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n                const relation = relationCountAttr.relation; // \"category.posts\"\n                const inverseRelation = relation.inverseRelation!; // \"post.category\"\n                const referenceColumnName = inverseRelation.joinColumns[0].referencedColumn!.propertyName; // post id\n                const inverseSideTable = relation.inverseEntityMetadata.target; // Post\n                const inverseSideTableName = relation.inverseEntityMetadata.tableName; // post\n                const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n                const inverseSidePropertyName = inverseRelation.propertyName; // \"category\" from \"post.category\"\n\n                let referenceColumnValues = rawEntities\n                    .map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + referenceColumnName])\n                    .filter(value => !!value);\n                referenceColumnValues = referenceColumnValues.filter(onlyUnique);\n\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (referenceColumnValues.length === 0)\n                    return { relationCountAttribute: relationCountAttr, results: [] };\n\n                // generate query:\n                // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n                qb.select(inverseSideTableAlias + \".\" + inverseSidePropertyName, \"parentId\")\n                    .addSelect(\"COUNT(*)\", \"cnt\")\n                    .from(inverseSideTable, inverseSideTableAlias)\n                    .where(inverseSideTableAlias + \".\" + inverseSidePropertyName + \" IN (:...ids)\")\n                    .addGroupBy(inverseSideTableAlias + \".\" + inverseSidePropertyName)\n                    .setParameter(\"ids\", referenceColumnValues);\n\n                // apply condition (custom query builder factory)\n                if (relationCountAttr.queryBuilderFactory)\n                    relationCountAttr.queryBuilderFactory(qb);\n\n                return {\n                    relationCountAttribute: relationCountAttr,\n                    results: await qb.getRawMany()\n                };\n\n            } else {\n                // example: Post and Category\n                // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                // we expect it to load array of post ids\n\n                let joinTableColumnName: string;\n                let inverseJoinColumnName: string;\n                let firstJunctionColumn: ColumnMetadata;\n                let secondJunctionColumn: ColumnMetadata;\n\n                if (relationCountAttr.relation.isOwning) { // todo fix joinColumns[0] and inverseJoinColumns[0].\n                    joinTableColumnName = relationCountAttr.relation.joinColumns[0].referencedColumn!.databaseName;\n                    inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn!.databaseName;\n                    firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata!.columns[0];\n                    secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata!.columns[1];\n\n                } else {\n                    joinTableColumnName = relationCountAttr.relation.inverseRelation!.inverseJoinColumns[0].referencedColumn!.databaseName;\n                    inverseJoinColumnName = relationCountAttr.relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName;\n                    firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata!.columns[1];\n                    secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata!.columns[0];\n                }\n\n                let referenceColumnValues = rawEntities\n                    .map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + joinTableColumnName])\n                    .filter(value => !!value);\n                referenceColumnValues = referenceColumnValues.filter(onlyUnique);\n\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (referenceColumnValues.length === 0)\n                    return { relationCountAttribute: relationCountAttr, results: [] };\n\n                const junctionAlias = relationCountAttr.junctionAlias;\n                const inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;\n                const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;\n                const junctionTableName = relationCountAttr.relation.junctionEntityMetadata!.tableName;\n                \n                const condition = junctionAlias + \".\" + firstJunctionColumn.propertyName + \" IN (\" + referenceColumnValues.map(vals => isNaN(vals) ? \"'\" + vals + \"'\" : vals) + \")\" +\n                    \" AND \" + junctionAlias + \".\" + secondJunctionColumn.propertyName + \" = \" + inverseSideTableAlias + \".\" + inverseJoinColumnName;\n\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n                qb.select(junctionAlias + \".\" + firstJunctionColumn.propertyName, \"parentId\")\n                    .addSelect(\"COUNT(\" + qb.escape(inverseSideTableAlias) + \".\" + qb.escape(inverseJoinColumnName) + \")\", \"cnt\")\n                    .from(inverseSideTableName, inverseSideTableAlias)\n                    .innerJoin(junctionTableName, junctionAlias, condition)\n                    .addGroupBy(junctionAlias + \".\" + firstJunctionColumn.propertyName);\n\n                // apply condition (custom query builder factory)\n                if (relationCountAttr.queryBuilderFactory)\n                    relationCountAttr.queryBuilderFactory(qb);\n\n                return {\n                    relationCountAttribute: relationCountAttr,\n                    results: await qb.getRawMany()\n                };\n            }\n        });\n\n        return Promise.all(promises);\n    }\n\n}\n"],"sourceRoot":"../.."}