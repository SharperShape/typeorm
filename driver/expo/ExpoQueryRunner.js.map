{"version":3,"sources":["../../src/driver/expo/ExpoQueryRunner.ts"],"names":[],"mappings":"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","file":"ExpoQueryRunner.js","sourcesContent":["import {QueryRunnerAlreadyReleasedError} from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport {QueryFailedError} from \"../../error/QueryFailedError\";\nimport {AbstractSqliteQueryRunner} from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport {TransactionAlreadyStartedError} from \"../../error/TransactionAlreadyStartedError\";\nimport {TransactionNotStartedError} from \"../../error/TransactionNotStartedError\";\nimport {ExpoDriver} from \"./ExpoDriver\";\nimport {Broadcaster} from \"../../subscriber/Broadcaster\";\n\n// Needed to satisfy the Typescript compiler\ninterface IResultSet {\n    insertId: number | undefined;\n    rowsAffected: number;\n    rows: {\n        length: number;\n        item: (idx: number) => any;\n        _array: any[];\n    };\n}\ninterface ITransaction {\n    executeSql: (\n        sql: string,\n        args: any[] | undefined,\n        ok: (tsx: ITransaction, resultSet: IResultSet) => void,\n        fail: (tsx: ITransaction, err: any) => void\n    ) => void;\n}\n\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class ExpoQueryRunner extends AbstractSqliteQueryRunner {\n    \n    /**\n     * Database driver used by connection.\n     */\n    driver: ExpoDriver;\n\n    /**\n     * Database transaction object\n     */\n    private transaction?: ITransaction;\n    \n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: ExpoDriver) {\n        super();\n        this.driver = driver;\n        this.connection = driver.connection;\n        this.broadcaster = new Broadcaster(this);\n    }\n\n    /**\n     * Starts transaction. Within Expo, all database operations happen in a\n     * transaction context, so issuing a `BEGIN TRANSACTION` command is\n     * redundant and will result in the following error:\n     * \n     * `Error: Error code 1: cannot start a transaction within a transaction`\n     * \n     * Instead, we keep track of a `Transaction` object in `this.transaction`\n     * and continue using the same object until we wish to commit the\n     * transaction.\n     */\n    async startTransaction(): Promise<void> {\n        if (this.isTransactionActive && typeof this.transaction !== \"undefined\")\n            throw new TransactionAlreadyStartedError();\n\n        this.isTransactionActive = true;\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     * Since Expo will automatically commit the transaction once all the\n     * callbacks of the transaction object have been completed, \"committing\" a\n     * transaction in this driver's context means that we delete the transaction\n     * object and set the stage for the next transaction.\n     */\n    async commitTransaction(): Promise<void> {\n        if (!this.isTransactionActive && typeof this.transaction === \"undefined\")\n            throw new TransactionNotStartedError();\n\n        this.isTransactionActive = false;\n        this.transaction = undefined;\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     * This method's functionality is identical to `commitTransaction()` because\n     * the transaction lifecycle is handled within the Expo transaction object.\n     * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (!this.isTransactionActive && typeof this.transaction === \"undefined\")\n            throw new TransactionNotStartedError();\n\n        this.isTransactionActive = false;\n        this.transaction = undefined;\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    query(query: string, parameters?: any[]): Promise<any> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        return new Promise<any>(async (ok, fail) => {\n            const databaseConnection = await this.connect();\n            this.driver.connection.logger.logQuery(query, parameters, this);\n            const queryStartTime = +new Date();\n            // All Expo SQL queries are executed in a transaction context\n            databaseConnection.transaction((transaction: ITransaction) => {\n                if (typeof this.transaction === \"undefined\") {\n                    this.startTransaction();\n                    this.transaction = transaction;\n                }\n                this.transaction.executeSql(query, parameters, (t: ITransaction, result: IResultSet) => {\n                    // log slow queries if maxQueryExecution time is set\n                    const maxQueryExecutionTime = this.driver.connection.options.maxQueryExecutionTime;\n                    const queryEndTime = +new Date();\n                    const queryExecutionTime = queryEndTime - queryStartTime;\n                    if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {\n                        this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n                    }\n    \n                    // return id of inserted row, if query was insert statement.\n                    if (query.substr(0, 11) === \"INSERT INTO\") {\n                        ok(result.insertId);\n                    }\n                    else {\n                        let resultSet = [];\n                        for (let i = 0; i < result.rows.length; i++) {\n                            resultSet.push(result.rows.item(i));\n                        }\n                        ok(resultSet);\n                    }\n                }, (t: ITransaction, err: any) => {\n                    this.driver.connection.logger.logQueryError(err, query, parameters, this);\n                    fail(new QueryFailedError(query, parameters, err));\n                });\n            }, (err: any) => {\n                this.rollbackTransaction();\n            }, () => {\n                this.isTransactionActive = false;\n                this.transaction = undefined;\n            });\n        });\n    }\n}\n"],"sourceRoot":"../.."}