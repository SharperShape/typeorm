{"version":3,"sources":["../../src/entity-manager/LiteralEntityManager.ts"],"names":[],"mappings":"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","file":"LiteralEntityManager.js","sourcesContent":["import {DeepPartial} from \"../common/DeepPartial\";\nimport {ObjectType} from \"../common/ObjectType\";\nimport {Connection} from \"../connection/Connection\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {ObjectID} from \"../driver/mongodb/typings\";\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\nimport {IsolationLevel} from \"../driver/types/IsolationLevel\";\nimport {CustomRepositoryCannotInheritRepositoryError} from \"../error/CustomRepositoryCannotInheritRepositoryError\";\nimport {CustomRepositoryNotFoundError} from \"../error/CustomRepositoryNotFoundError\";\nimport {EntityNotFoundError} from \"../error/EntityNotFoundError\";\nimport {NoNeedToReleaseEntityManagerError} from \"../error/NoNeedToReleaseEntityManagerError\";\nimport {QueryRunnerProviderAlreadyReleasedError} from \"../error/QueryRunnerProviderAlreadyReleasedError\";\nimport {TreeRepositoryNotSupportedError} from \"../error/TreeRepositoryNotSupportedError\";\nimport {QueryDeepPartialEntity} from \"../query-builder/QueryPartialEntity\";\nimport {FindExtraOptions, FindOptions, FindOptionsWhere} from \"../find-options/FindOptions\";\nimport {FindOptionsUtils} from \"../find-options/FindOptionsUtils\";\nimport { EntityManager, EntitySchema, getMetadataArgsStorage } from \"../index\";\nimport {ObserverExecutor} from \"../observer/ObserverExecutor\";\nimport {QueryObserver} from \"../observer/QueryObserver\";\nimport {EntityPersistExecutor} from \"../persistence/EntityPersistExecutor\";\nimport {DeleteResult} from \"../query-builder/result/DeleteResult\";\nimport {InsertResult} from \"../query-builder/result/InsertResult\";\nimport {UpdateResult} from \"../query-builder/result/UpdateResult\";\nimport {SelectQueryBuilder} from \"../query-builder/SelectQueryBuilder\";\nimport {PlainObjectToDatabaseEntityTransformer} from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\";\nimport {PlainObjectToNewEntityTransformer} from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {AbstractRepository} from \"../repository/AbstractRepository\";\nimport {MongoRepository} from \"../repository/MongoRepository\";\nimport {RemoveOptions} from \"../repository/RemoveOptions\";\nimport {Repository} from \"../repository/Repository\";\nimport {SaveOptions} from \"../repository/SaveOptions\";\nimport {TreeRepository} from \"../repository/TreeRepository\";\nimport {ObjectUtils} from \"../util/ObjectUtils\";\nimport { Observable } from \"zen-observable-ts\";\nimport {createLiteralTreeRepository} from \"../repository/LiteralTreeRepository\";\nimport {EntityTarget} from \"../common/EntityTarget\";\nimport {createLiteralMongoRepository} from \"../repository/LiteralMongoRepository\";\nimport {createLiteralRepository} from \"../repository/LiteralRepository\";\n\n/**\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\n * whatever entity type are you passing.\n */\nexport function createLiteralEntityManager({ connection, queryRunner }: {\n    connection: Connection,\n    queryRunner?: QueryRunner,\n}): EntityManager {\n\n    /**\n     * Once created and then reused by repositories.\n     */\n    const repositories: Repository<any>[] = [];\n\n    /**\n     * Once created and then reused by repositories.\n     */\n    const treeRepositories: TreeRepository<any>[] = [];\n\n    /**\n     * Plain to object transformer used in create and merge operations.\n     */\n    const plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer();\n\n    const manager: EntityManager = {\n        typeof: \"EntityManager\",\n        connection: connection,\n        queryRunner: queryRunner,\n\n        async transaction<T>(\n            isolationOrRunInTransaction: IsolationLevel | ((entityManager: EntityManager) => Promise<T>),\n            runInTransactionParam?: (entityManager: EntityManager) => Promise<T>\n        ): Promise<T> {\n\n            const isolation = typeof isolationOrRunInTransaction === \"string\" ? isolationOrRunInTransaction : undefined;\n            const runInTransaction = typeof isolationOrRunInTransaction === \"function\" ? isolationOrRunInTransaction : runInTransactionParam;\n\n            if (!runInTransaction) {\n                throw new Error(`Transaction method requires callback in second paramter if isolation level is supplied.`);\n            }\n\n            if (this.connection.driver instanceof MongoDriver)\n                throw new Error(`Transactions aren't supported by MongoDB.`);\n\n            if (this.queryRunner && this.queryRunner.isReleased)\n                throw new QueryRunnerProviderAlreadyReleasedError();\n\n            if (this.queryRunner && this.queryRunner.isTransactionActive)\n                throw new Error(`Cannot start transaction because its already started`);\n\n            // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n            // if its not defined we create a new query runner - single connection where we'll execute all our operations\n            const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n\n            try {\n                if (isolation) {\n                    await queryRunner.startTransaction(isolation);\n                } else {\n                    await queryRunner.startTransaction();\n                }\n                const result = await runInTransaction(queryRunner.manager);\n                await queryRunner.commitTransaction();\n                await new ObserverExecutor(this.connection.observers).execute();\n                return result;\n\n            } catch (err) {\n                try { // we throw original error even if rollback thrown an error\n                    await queryRunner.rollbackTransaction();\n                } catch (rollbackError) {\n                }\n                throw err;\n\n            } finally {\n                if (!this.queryRunner) // if we used a new query runner provider then release it\n                    await queryRunner.release();\n            }\n        },\n\n        async query(query: string, parameters?: any[]): Promise<any> {\n            return this.connection.query(query, parameters, this.queryRunner);\n        },\n\n        createQueryBuilder<Entity>(entityClass?: EntityTarget<Entity> | QueryRunner, alias?: string, queryRunner?: QueryRunner): SelectQueryBuilder<Entity> {\n            if (alias) {\n                return this.connection.createQueryBuilder(entityClass as EntitySchema<Entity> | string, alias, queryRunner || this.queryRunner);\n\n            } else {\n                return this.connection.createQueryBuilder(entityClass as QueryRunner | undefined || queryRunner || this.queryRunner);\n            }\n        },\n\n        hasId(targetOrEntity: any | Function | string, maybeEntity?: any): boolean {\n            const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n            const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n            const metadata = this.connection.getMetadata(target);\n            return metadata.hasId(entity);\n        },\n\n        getId(targetOrEntity: any | Function | string, maybeEntity?: any): any {\n            const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n            const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n            const metadata = this.connection.getMetadata(target);\n            return metadata.getEntityIdMixedMap(entity);\n        },\n\n        create<Entity>(entityClass: EntityTarget<Entity>, plainObjectOrObjects?: DeepPartial<Entity> | DeepPartial<Entity>[]): Entity | Entity[] {\n            const metadata = this.connection.getMetadata(entityClass);\n\n            if (!plainObjectOrObjects)\n                return metadata.create(this.queryRunner);\n\n            if (Array.isArray(plainObjectOrObjects))\n                return plainObjectOrObjects.map(plainEntityLike => this.create(entityClass as any, plainEntityLike));\n\n            const mergeIntoEntity = metadata.create(this.queryRunner);\n            plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);\n            return mergeIntoEntity;\n        },\n\n        merge<Entity>(entityClass: EntityTarget<Entity>, mergeIntoEntity: Entity, ...entityLikes: DeepPartial<Entity>[]): Entity { // todo: throw exception if entity manager is released\n            const metadata = this.connection.getMetadata(entityClass);\n            entityLikes.forEach(object => plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata));\n            return mergeIntoEntity;\n        },\n\n        async preload<Entity>(entityClass: EntityTarget<Entity>, entityLike: DeepPartial<Entity>): Promise<Entity | undefined> {\n            const metadata = this.connection.getMetadata(entityClass);\n            const plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer(this.connection.manager);\n            const transformedEntity = await plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata);\n            if (transformedEntity)\n                return this.merge(entityClass as any, transformedEntity as Entity, entityLike);\n\n            return undefined;\n        },\n\n        save<Entity, T extends DeepPartial<Entity>>(targetOrEntity: (T | T[]) | EntityTarget<Entity>, maybeEntityOrOptions?: T | T[], maybeOptions?: SaveOptions): Promise<T | T[]> {\n\n            // normalize mixed parameters\n            let target = (arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function | string : undefined;\n            const entity: T | T[] = target ? maybeEntityOrOptions as T | T[] : targetOrEntity as T | T[];\n            const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n            if (target instanceof EntitySchema)\n                target = target.options.name;\n\n            // if user passed empty array of entities then we don't need to do anything\n            if (Array.isArray(entity) && entity.length === 0)\n                return Promise.resolve(entity);\n\n            // execute save operation\n            return new EntityPersistExecutor(this.connection, this.queryRunner, \"save\", target, entity, options)\n                .execute()\n                .then(() => entity);\n        },\n\n        remove<Entity>(targetOrEntity: (Entity | Entity[]) | Function | string, maybeEntityOrOptions?: Entity | Entity[], maybeOptions?: RemoveOptions): Promise<Entity | Entity[]> {\n\n            // normalize mixed parameters\n            const target = (arguments.length > 1 && (targetOrEntity instanceof Function || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function | string : undefined;\n            const entity: Entity | Entity[] = target ? maybeEntityOrOptions as Entity | Entity[] : targetOrEntity as Entity | Entity[];\n            const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n            // if user passed empty array of entities then we don't need to do anything\n            if (Array.isArray(entity) && entity.length === 0)\n                return Promise.resolve(entity);\n\n            // execute save operation\n            return new EntityPersistExecutor(this.connection, this.queryRunner, \"remove\", target, entity, options)\n                .execute()\n                .then(() => entity);\n        },\n\n        softRemove<Entity, T extends DeepPartial<Entity>>(targetOrEntity: (T | T[]) | ObjectType<Entity> | EntitySchema<Entity> | string, maybeEntityOrOptions?: T | T[], maybeOptions?: SaveOptions): Promise<T | T[]> {\n\n            // normalize mixed parameters\n            let target = (arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function | string : undefined;\n            const entity: T | T[] = target ? maybeEntityOrOptions as T | T[] : targetOrEntity as T | T[];\n            const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n            if (target instanceof EntitySchema)\n                target = target.options.name;\n\n            // if user passed empty array of entities then we don't need to do anything\n            if (Array.isArray(entity) && entity.length === 0)\n                return Promise.resolve(entity);\n\n            // execute soft-remove operation\n            return new EntityPersistExecutor(this.connection, this.queryRunner, \"soft-remove\", target, entity, options)\n                .execute()\n                .then(() => entity);\n        },\n\n        recover<Entity, T extends DeepPartial<Entity>>(targetOrEntity: (T | T[]) | ObjectType<Entity> | EntitySchema<Entity> | string, maybeEntityOrOptions?: T | T[], maybeOptions?: SaveOptions): Promise<T | T[]> {\n\n            // normalize mixed parameters\n            let target = (arguments.length > 1 && (targetOrEntity instanceof Function || targetOrEntity instanceof EntitySchema || typeof targetOrEntity === \"string\")) ? targetOrEntity as Function | string : undefined;\n            const entity: T | T[] = target ? maybeEntityOrOptions as T | T[] : targetOrEntity as T | T[];\n            const options = target ? maybeOptions : maybeEntityOrOptions as SaveOptions;\n\n            if (target instanceof EntitySchema)\n                target = target.options.name;\n\n            // if user passed empty array of entities then we don't need to do anything\n            if (Array.isArray(entity) && entity.length === 0)\n                return Promise.resolve(entity);\n\n            // execute recover operation\n            return new EntityPersistExecutor(this.connection, this.queryRunner, \"recover\", target, entity, options)\n                .execute()\n                .then(() => entity);\n        },\n\n        async insert<Entity>(target: EntityTarget<Entity>, entity: QueryDeepPartialEntity<Entity> | (QueryDeepPartialEntity<Entity>[])): Promise<InsertResult> {\n\n            // TODO: Oracle does not support multiple values. Need to create another nice solution.\n            if (this.connection.driver instanceof OracleDriver && Array.isArray(entity)) {\n                const results = await Promise.all(entity.map(entity => this.insert(target, entity)));\n                return results.reduce((mergedResult, result) => Object.assign(mergedResult, result), {} as InsertResult);\n            }\n            return this.createQueryBuilder()\n                .insert()\n                .into(target)\n                .values(entity)\n                .execute();\n        },\n\n        update<Entity>(target: EntityTarget<Entity>, criteria: string | string[] | number | number[] | Date | Date[] | ObjectID | ObjectID[] | FindOptionsWhere<Entity>, partialEntity: QueryDeepPartialEntity<Entity>): Promise<UpdateResult> {\n\n            // if user passed empty criteria or empty list of criterias, then throw an error\n            if (criteria === undefined ||\n                criteria === null ||\n                criteria === \"\" ||\n                (Array.isArray(criteria) && criteria.length === 0)) {\n\n                return Promise.reject(new Error(`Empty criteria(s) are not allowed for the update method.`));\n            }\n\n            if (typeof criteria === \"string\" ||\n                typeof criteria === \"number\" ||\n                criteria instanceof Date ||\n                Array.isArray(criteria)) {\n\n                return this.createQueryBuilder()\n                    .update(target)\n                    .set(partialEntity)\n                    .whereInIds(criteria)\n                    .execute();\n\n            } else {\n                return this.createQueryBuilder()\n                    .update(target)\n                    .set(partialEntity)\n                    .where(criteria)\n                    .execute();\n            }\n        },\n\n        delete<Entity>(targetOrEntity: EntityTarget<Entity>, criteria: string | string[] | number | number[] | Date | Date[] | ObjectID | ObjectID[] | FindOptionsWhere<Entity>): Promise<DeleteResult> {\n\n            // if user passed empty criteria or empty list of criterias, then throw an error\n            if (criteria === undefined ||\n                criteria === null ||\n                criteria === \"\" ||\n                (Array.isArray(criteria) && criteria.length === 0)) {\n\n                return Promise.reject(new Error(`Empty criteria(s) are not allowed for the delete method.`));\n            }\n\n            if (typeof criteria === \"string\" ||\n                typeof criteria === \"number\" ||\n                criteria instanceof Date ||\n                Array.isArray(criteria)) {\n\n                return this.createQueryBuilder()\n                    .delete()\n                    .from(targetOrEntity)\n                    .whereInIds(criteria)\n                    .execute();\n\n            } else {\n                return this.createQueryBuilder()\n                    .delete()\n                    .from(targetOrEntity)\n                    .where(criteria)\n                    .execute();\n            }\n        },\n\n        softDelete<Entity>(targetOrEntity: ObjectType<Entity> | EntitySchema<Entity> | string, criteria: string | string[] | number | number[] | Date | Date[] | ObjectID | ObjectID[] | any): Promise<UpdateResult> {\n\n            // if user passed empty criteria or empty list of criterias, then throw an error\n            if (criteria === undefined ||\n                criteria === null ||\n                criteria === \"\" ||\n                (Array.isArray(criteria) && criteria.length === 0)) {\n\n                return Promise.reject(new Error(`Empty criteria(s) are not allowed for the delete method.`));\n            }\n\n            if (typeof criteria === \"string\" ||\n                typeof criteria === \"number\" ||\n                criteria instanceof Date ||\n                Array.isArray(criteria)) {\n\n                return this.createQueryBuilder()\n                    .softDelete()\n                    .from(targetOrEntity)\n                    .whereInIds(criteria)\n                    .execute();\n\n            } else {\n                return this.createQueryBuilder()\n                    .softDelete()\n                    .from(targetOrEntity)\n                    .where(criteria)\n                    .execute();\n            }\n        },\n\n    restore<Entity>(targetOrEntity: ObjectType<Entity> | EntitySchema<Entity> | string, criteria: string | string[] | number | number[] | Date | Date[] | ObjectID | ObjectID[] | any): Promise<UpdateResult> {\n\n            // if user passed empty criteria or empty list of criterias, then throw an error\n            if (criteria === undefined ||\n                criteria === null ||\n                criteria === \"\" ||\n                (Array.isArray(criteria) && criteria.length === 0)) {\n\n                return Promise.reject(new Error(`Empty criteria(s) are not allowed for the delete method.`));\n            }\n\n            if (typeof criteria === \"string\" ||\n                typeof criteria === \"number\" ||\n                criteria instanceof Date ||\n                Array.isArray(criteria)) {\n\n                return this.createQueryBuilder()\n                    .restore()\n                    .from(targetOrEntity)\n                    .whereInIds(criteria)\n                    .execute();\n\n            } else {\n                return this.createQueryBuilder()\n                    .restore()\n                    .from(targetOrEntity)\n                    .where(criteria)\n                    .execute();\n            }\n        },\n\n        async count<Entity>(entityClass: EntityTarget<Entity>, conditions?: FindOptionsWhere<Entity>, options?: FindExtraOptions): Promise<number> {\n            const metadata = this.connection.getMetadata(entityClass);\n            const qb = this.createQueryBuilder(entityClass as any, metadata.name);\n\n            qb.setFindOptions({\n                where: conditions,\n                options: options\n            });\n\n            return qb.getCount();\n        },\n\n        async find<Entity>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindOptions<Entity> | FindOptionsWhere<Entity>): Promise<Entity[]> {\n            const metadata = this.connection.getMetadata(entityClass);\n            const qb = this.createQueryBuilder(entityClass as any, metadata.name);\n\n            if (optionsOrConditions)\n                qb.setFindOptions(FindOptionsUtils.isFindOptions(optionsOrConditions) ? optionsOrConditions as any : {where: optionsOrConditions});\n\n            return qb.getMany();\n        },\n\n        async findAndCount<Entity>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindOptions<Entity> | FindOptionsWhere<Entity>): Promise<[Entity[], number]> {\n            const metadata = this.connection.getMetadata(entityClass);\n            const qb = this.createQueryBuilder(entityClass as any, metadata.name);\n\n            if (optionsOrConditions)\n                qb.setFindOptions(FindOptionsUtils.isFindOptions(optionsOrConditions) ? optionsOrConditions as any : {where: optionsOrConditions});\n\n            return qb.getManyAndCount();\n        },\n\n        async findByIds<Entity>(entityClass: EntityTarget<Entity>, ids: any[], optionsOrConditions?: FindOptions<Entity> | any): Promise<Entity[]> {\n\n            // if no ids passed, no need to execute a query - just return an empty array of values\n            if (!ids.length)\n                return Promise.resolve([]);\n\n            const metadata = this.connection.getMetadata(entityClass);\n            const qb = this.createQueryBuilder(entityClass as any, metadata.name);\n            // FindOptionsUtils.applyFindOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions);\n\n            // todo: implement only-find options it later\n            // let options: FindOptions<any> = { };\n            // if (optionsOrConditions) {\n            //     if (FindOptionsUtils.isFindOptions(optionsOrConditions)) {\n            //         options = optionsOrConditions;\n            //     } else {\n            //         options = { where: optionsOrConditions };\n            //     }\n            // }\n            // if (!options.where) {\n            //     options.where = {  };\n            // }\n            // return qb.setFindOptions(optionsOrConditions).getMany();\n\n            const findOptions: FindOptions<Entity> = {};\n            if (FindOptionsUtils.isFindOptions(optionsOrConditions)) {\n                Object.assign(findOptions, optionsOrConditions);\n            } else if (optionsOrConditions) {\n                Object.assign(findOptions, {where: optionsOrConditions});\n            }\n\n            // if (findOptions.where || metadata.primaryColumns.length > 1) {\n            return qb\n                .setFindOptions(findOptions)\n                .andWhereInIds(ids)\n                .getMany();\n            // }\n\n            // this is for optimization purpose\n            // findOptions.where = {};\n            // const primaryColumn = metadata.primaryColumns[0];\n            // const normalizedIds = ids.map(id => {\n            //     return typeof id === \"object\" ? primaryColumn.getEntityValue(id) : id;\n            // });\n            // primaryColumn.setEntityValue(findOptions.where, In(normalizedIds));\n\n            // console.log(\"WHERE:\", findOptions);\n            // qb.setFindOptions(findOptions);\n            // const results = await qb.getMany();\n            // console.log(\"results\", results);\n            // return results;\n        },\n        /**\n         * @param entityClass\n         * @param {string | string[] | number | number[] | Date | Date[] | ObjectID | ObjectID[] | FindOptions<Entity> | any} [idOrOptionsOrConditions]\n         * @param {FindOptions<Entity>} [maybeOptions]\n         */\n        findOne<Entity>(\n            entityClass: EntityTarget<Entity>,\n            ...args: (string | string[] | number | number[] | Date | Date[] | ObjectID | ObjectID[] | FindOptions<Entity> | any)[]\n        ): Promise<Entity | undefined> {\n            if (args.length > 2) {\n                throw new Error(\"Too many arguments.\");\n            }\n\n            const idOrOptionsOrConditions = args[0];\n            const maybeOptions = args[1];\n\n            if (args.length >= 1) {\n                if (idOrOptionsOrConditions === undefined || idOrOptionsOrConditions === null || idOrOptionsOrConditions === false) {\n                    return Promise.resolve(undefined);\n                }\n            }\n\n            let findOptions: FindOptions<any> | undefined = undefined;\n            if (FindOptionsUtils.isFindOptions(idOrOptionsOrConditions)) {\n                findOptions = idOrOptionsOrConditions;\n            } else if (maybeOptions && FindOptionsUtils.isFindOptions(maybeOptions)) {\n                findOptions = maybeOptions;\n            }\n\n            let options: FindOptionsWhere<Entity> | undefined = undefined;\n            if (idOrOptionsOrConditions instanceof Object && !FindOptionsUtils.isFindOptions(idOrOptionsOrConditions))\n                options = idOrOptionsOrConditions as FindOptionsWhere<Entity>;\n\n            const metadata = this.connection.getMetadata(entityClass);\n            const qb = this.createQueryBuilder(entityClass as any, metadata.name);\n\n            // if (!findOptions || findOptions.loadEagerRelations !== false)\n            //     FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias!.metadata);\n\n            const findById = typeof idOrOptionsOrConditions === \"string\" || typeof idOrOptionsOrConditions === \"number\" || idOrOptionsOrConditions instanceof Date;\n\n            if (!findById) {\n                findOptions = {\n                    ...(findOptions || {}),\n                    take: 1,\n                };\n            }\n\n            if (findOptions) {\n                qb.setFindOptions(findOptions);\n            }\n\n            if (options) {\n                qb.where(options);\n\n            } else if (findById) {\n                qb.andWhereInIds(metadata.ensureEntityIdMap(idOrOptionsOrConditions));\n            }\n\n            return qb.getOne();\n        },\n\n        async findOneOrFail<Entity>(\n            entityClass: EntityTarget<Entity>,\n            ...args: (string | string[] | number | number[] | Date | Date[] | ObjectID | ObjectID[] | FindOptions<Entity> | any)[]\n        ): Promise<Entity> {\n            return this.findOne(entityClass as any, ...args).then((value: any) => {\n                if (value === undefined) {\n                    return Promise.reject(new EntityNotFoundError(entityClass, args.length > 0 ? args[0]: undefined));\n                }\n                return Promise.resolve(value);\n            });\n        },\n\n        observe<Entity>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindOptions<Entity> | FindOptionsWhere<Entity>): Observable<Entity[]> {\n            const metadata = this.connection.getMetadata(entityClass);\n            return new QueryObserver(this.connection, \"find\", metadata, optionsOrConditions).observe();\n        },\n\n        observeManyAndCount<Entity>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindOptions<Entity> | FindOptionsWhere<Entity>): Observable<[Entity[], number]> {\n            const metadata = this.connection.getMetadata(entityClass);\n            return new QueryObserver(this.connection, \"findAndCount\", metadata, optionsOrConditions).observe();\n        },\n\n        observeOne<Entity>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindOptions<Entity> | FindOptionsWhere<Entity>): Observable<Entity> {\n            const metadata = this.connection.getMetadata(entityClass);\n            return new QueryObserver(this.connection, \"findOne\", metadata, optionsOrConditions).observe();\n        },\n\n        observeCount<Entity>(entityClass: EntityTarget<Entity>, optionsOrConditions?: FindOptions<Entity> | FindOptionsWhere<Entity>): Observable<number> {\n            const metadata = this.connection.getMetadata(entityClass);\n            return new QueryObserver(this.connection, \"count\", metadata, optionsOrConditions).observe();\n        },\n\n        async clear<Entity>(entityClass: EntityTarget<Entity>): Promise<void> {\n            const metadata = this.connection.getMetadata(entityClass);\n            const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n            try {\n                return await queryRunner.clearTable(metadata.tablePath); // await is needed here because we are using finally\n\n            } finally {\n                if (!this.queryRunner)\n                    await queryRunner.release();\n            }\n        },\n\n        async increment<Entity>(entityClass: EntityTarget<Entity>,\n                                conditions: FindOptionsWhere<Entity>,\n                                propertyPath: string,\n                                value: number | string): Promise<UpdateResult> {\n\n            const metadata = this.connection.getMetadata(entityClass);\n            const column = metadata.findColumnWithPropertyPath(propertyPath);\n            if (!column)\n                throw new Error(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n\n            if (isNaN(Number(value)))\n                throw new Error(`Value \"${value}\" is not a number.`);\n\n            // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n            const values: QueryDeepPartialEntity<Entity> = propertyPath\n                .split(\".\")\n                .reduceRight(\n                    (value, key) => ({[key]: value}) as any,\n                    () => this.connection.driver.escape(column.databaseName) + \" + \" + value\n                );\n\n            return this\n                .createQueryBuilder(entityClass as any, \"entity\")\n                .update(entityClass)\n                .set(values)\n                .where(conditions)\n                .execute();\n        },\n\n        async decrement<Entity>(entityClass: EntityTarget<Entity>,\n                                conditions: FindOptionsWhere<Entity>,\n                                propertyPath: string,\n                                value: number | string): Promise<UpdateResult> {\n\n            const metadata = this.connection.getMetadata(entityClass);\n            const column = metadata.findColumnWithPropertyPath(propertyPath);\n            if (!column)\n                throw new Error(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n\n            if (isNaN(Number(value)))\n                throw new Error(`Value \"${value}\" is not a number.`);\n\n            // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n            const values: QueryDeepPartialEntity<Entity> = propertyPath\n                .split(\".\")\n                .reduceRight(\n                    (value, key) => ({[key]: value}) as any,\n                    () => this.connection.driver.escape(column.databaseName) + \" - \" + value\n                );\n\n            return this\n                .createQueryBuilder(entityClass as any, \"entity\")\n                .update(entityClass)\n                .set(values)\n                .where(conditions)\n                .execute();\n        },\n\n        getRepository<Entity>(target: EntityTarget<Entity>): Repository<Entity> {\n\n            // find already created repository instance and return it if found\n            const repository = repositories.find(repository => repository.target === target);\n            if (repository)\n                return repository;\n\n            // if repository was not found then create it, store its instance and return it\n            if (this.connection.driver instanceof MongoDriver) {\n                const newRepository = createLiteralMongoRepository({\n                    manager: this as any,\n                    target,\n                    queryRunner: this.queryRunner,\n                });\n                repositories.push(newRepository);\n                return newRepository;\n\n            } else {\n                const newRepository = createLiteralRepository({\n                    manager: this,\n                    target,\n                    queryRunner: this.queryRunner,\n                });\n                repositories.push(newRepository);\n                return newRepository;\n            }\n        },\n\n        getTreeRepository<Entity>(target: EntityTarget<Entity>): TreeRepository<Entity> {\n\n            // tree tables aren't supported by some drivers (mongodb)\n            if (this.connection.driver.treeSupport === false)\n                throw new TreeRepositoryNotSupportedError(this.connection.driver);\n\n            // find already created repository instance and return it if found\n            const repository = treeRepositories.find(repository => repository.target === target);\n            if (repository)\n                return repository;\n\n            // check if repository is real tree repository\n            const newRepository = createLiteralTreeRepository({\n                manager: this,\n                target,\n                queryRunner: this.queryRunner,\n            });\n            treeRepositories.push(newRepository);\n            return newRepository;\n        },\n\n        getMongoRepository<Entity>(target: EntityTarget<Entity>): MongoRepository<Entity> {\n            return connection.getMongoRepository<Entity>(target);\n        },\n\n        getCustomRepository<T>(customRepository: ObjectType<T>): T {\n            const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(repository => {\n                return repository.target === (customRepository instanceof Function ? customRepository : (customRepository as any).constructor);\n            });\n            if (!entityRepositoryMetadataArgs)\n                throw new CustomRepositoryNotFoundError(customRepository);\n\n            const entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : undefined;\n            const entityRepositoryInstance = new (entityRepositoryMetadataArgs.target as any)(this, entityMetadata);\n\n            // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,\n            // however we need these properties for internal work of the class\n            if (entityRepositoryInstance instanceof AbstractRepository) {\n                if (!(entityRepositoryInstance as any)[\"manager\"])\n                    (entityRepositoryInstance as any)[\"manager\"] = this;\n            } else {\n                if (!entityMetadata)\n                    throw new CustomRepositoryCannotInheritRepositoryError(customRepository);\n\n                (entityRepositoryInstance as any)[\"manager\"] = this;\n                (entityRepositoryInstance as any)[\"metadata\"] = entityMetadata;\n            }\n\n            return entityRepositoryInstance;\n        },\n\n        async release(): Promise<void> {\n            if (!this.queryRunner)\n                throw new NoNeedToReleaseEntityManagerError();\n\n            return this.queryRunner.release();\n        }\n\n    };\n\n    if (queryRunner) {\n        // dynamic: this.queryRunner = manager;\n        ObjectUtils.assign(queryRunner, { manager });\n    }\n\n    return manager;\n}\n"],"sourceRoot":".."}