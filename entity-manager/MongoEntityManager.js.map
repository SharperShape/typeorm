{"version":3,"sources":["../../src/entity-manager/MongoEntityManager.ts"],"names":[],"mappings":"","file":"MongoEntityManager.js","sourcesContent":["import { EntityManager } from \"./EntityManager\";\nimport { EntityTarget } from \"../common/EntityTarget\";\nimport {\n    AggregationCursor,\n    BulkWriteOpResultObject,\n    ChangeStream,\n    ChangeStreamOptions,\n    Code,\n    Collection,\n    CollectionAggregationOptions,\n    CollectionBulkWriteOptions,\n    CollectionInsertManyOptions,\n    CollectionInsertOneOptions,\n    CollectionOptions,\n    CollStats,\n    CommandCursor,\n    Cursor,\n    DeleteWriteOpResultObject,\n    FindAndModifyWriteOpResultObject,\n    FindOneAndReplaceOption,\n    GeoHaystackSearchOptions,\n    GeoNearOptions,\n    InsertOneWriteOpResult,\n    InsertWriteOpResult,\n    MapReduceOptions,\n    MongoCountPreferences,\n    MongodbIndexOptions,\n    ObjectID,\n    OrderedBulkOperation,\n    ParallelCollectionScanOptions,\n    ReadPreference,\n    ReplaceOneOptions,\n    UnorderedBulkOperation,\n    UpdateWriteOpResult\n} from \"../driver/mongodb/typings\";\nimport { FindOptions, FindOptionsWhere } from \"../find-options/FindOptions\";\nimport { FindExtraOptions } from \"../index\";\nimport { ObjectLiteral } from \"../common/ObjectLiteral\";\nimport { MongoQueryRunner } from \"../driver/mongodb/MongoQueryRunner\";\nimport { QueryDeepPartialEntity } from \"../query-builder/QueryPartialEntity\";\nimport { InsertResult } from \"../query-builder/result/InsertResult\";\nimport { UpdateResult } from \"../query-builder/result/UpdateResult\";\nimport { DeleteResult } from \"../query-builder/result/DeleteResult\";\n\n/**\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\n * whatever entity type are you passing.\n *\n * This implementation is used for MongoDB driver which has some specifics in its EntityManager.\n */\nexport type MongoEntityManager = EntityManager & {\n\n    /**\n     * Gets query runner used to execute queries.\n     */\n    queryRunner: MongoQueryRunner\n\n    // -------------------------------------------------------------------------\n    // Overridden Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Finds entities that match given find options or conditions.\n     */\n    find<Entity>(entityClassOrName: EntityTarget<Entity>, optionsOrConditions?: FindOptions<Entity> | FindOptionsWhere<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds entities that match given find options or conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount<Entity>(entityClassOrName: EntityTarget<Entity>, optionsOrConditions?: FindOptions<Entity> | FindOptionsWhere<Entity>): Promise<[Entity[], number]>;\n\n    /**\n     * Finds entities by ids.\n     * Optionally find options can be applied.\n     */\n    findByIds<Entity>(entityClassOrName: EntityTarget<Entity>, ids: any[], optionsOrConditions?: FindOptions<Entity> | FindOptionsWhere<Entity>): Promise<Entity[]>;\n\n    /**\n     * Finds first entity that matches given conditions and/or find options.\n     */\n    findOne<Entity>(entityClassOrName: EntityTarget<Entity>,\n                  optionsOrConditions?: string | string[] | number | number[] | Date | Date[] | ObjectID | ObjectID[] | FindOptions<Entity> | FindOptionsWhere<Entity>,\n                  maybeOptions?: FindOptions<Entity>): Promise<Entity | undefined>;\n\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     * You can execute bulk inserts using this method.\n     */\n    insert<Entity>(target: EntityTarget<Entity>, entity: QueryDeepPartialEntity<Entity> | QueryDeepPartialEntity<Entity>[]): Promise<InsertResult>;\n\n    /**\n     * Updates entity partially. Entity can be found by a given conditions.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     */\n    update<Entity>(target: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindOptionsWhere<Entity>, partialEntity: QueryDeepPartialEntity<Entity>): Promise<UpdateResult>;\n\n    /**\n     * Deletes entities by a given conditions.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     */\n    delete<Entity>(target: EntityTarget<Entity>, criteria: string|string[]|number|number[]|Date|Date[]|ObjectID|ObjectID[]|FindOptionsWhere<Entity>): Promise<DeleteResult>;\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a cursor for a query that can be used to iterate over results from MongoDB.\n     */\n    createCursor<Entity, T = any>(entityClassOrName: EntityTarget<Entity>, query?: ObjectLiteral): Cursor<T>;\n\n    /**\n     * Creates a cursor for a query that can be used to iterate over results from MongoDB.\n     * This returns modified version of cursor that transforms each result into Entity model.\n     */\n    createEntityCursor<Entity>(entityClassOrName: EntityTarget<Entity>, query?: ObjectLiteral): Cursor<Entity>;\n\n    /**\n     * Execute an aggregation framework pipeline against the collection.\n     */\n    aggregate<Entity, R = any>(entityClassOrName: EntityTarget<Entity>, pipeline: ObjectLiteral[], options?: CollectionAggregationOptions): AggregationCursor<R>;\n\n    /**\n     * Execute an aggregation framework pipeline against the collection.\n     * This returns modified version of cursor that transforms each result into Entity model.\n     */\n    aggregateEntity<Entity>(entityClassOrName: EntityTarget<Entity>, pipeline: ObjectLiteral[], options?: CollectionAggregationOptions): AggregationCursor<Entity>;\n\n    /**\n     * Perform a bulkWrite operation without a fluent API.\n     */\n    bulkWrite<Entity>(entityClassOrName: EntityTarget<Entity>, operations: ObjectLiteral[], options?: CollectionBulkWriteOptions): Promise<BulkWriteOpResultObject>;\n\n    /**\n     * Count number of matching documents in the db to a query.\n     */\n    count<Entity>(entityClassOrName: EntityTarget<Entity>, query?: ObjectLiteral, options?: FindExtraOptions, mongoOptions?: MongoCountPreferences): Promise<number>;\n\n    /**\n     * Creates an index on the db and collection.\n     */\n    createCollectionIndex<Entity>(entityClassOrName: EntityTarget<Entity>, fieldOrSpec: string | any, options?: MongodbIndexOptions): Promise<string>;\n\n    /**\n     * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.\n     * Earlier version of MongoDB will throw a command not supported error.\n     * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.\n     */\n    createCollectionIndexes<Entity>(entityClassOrName: EntityTarget<Entity>, indexSpecs: ObjectLiteral[]): Promise<void>;\n\n    /**\n     * Delete multiple documents on MongoDB.\n     */\n    deleteMany<Entity>(entityClassOrName: EntityTarget<Entity>, query: ObjectLiteral, options?: CollectionOptions): Promise<DeleteWriteOpResultObject>;\n\n    /**\n     * Delete a document on MongoDB.\n     */\n    deleteOne<Entity>(entityClassOrName: EntityTarget<Entity>, query: ObjectLiteral, options?: CollectionOptions): Promise<DeleteWriteOpResultObject>;\n\n    /**\n     * The distinct command returns returns a list of distinct values for the given key across a collection.\n     */\n    distinct<Entity>(entityClassOrName: EntityTarget<Entity>, key: string, query: ObjectLiteral, options?: { readPreference?: ReadPreference | string }): Promise<any>;\n\n    /**\n     * Drops an index from this collection.\n     */\n    dropCollectionIndex<Entity>(entityClassOrName: EntityTarget<Entity>, indexName: string, options?: CollectionOptions): Promise<any>;\n\n    /**\n     * Drops all indexes from the collection.\n     */\n    dropCollectionIndexes<Entity>(entityClassOrName: EntityTarget<Entity>): Promise<any>;\n\n    /**\n     * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.\n     */\n    findOneAndDelete<Entity>(entityClassOrName: EntityTarget<Entity>, query: ObjectLiteral, options?: { projection?: Object, sort?: Object, maxTimeMS?: number }): Promise<FindAndModifyWriteOpResultObject>;\n\n    /**\n     * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.\n     */\n    findOneAndReplace<Entity>(entityClassOrName: EntityTarget<Entity>, query: ObjectLiteral, replacement: Object, options?: FindOneAndReplaceOption): Promise<FindAndModifyWriteOpResultObject>;\n\n    /**\n     * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.\n     */\n    findOneAndUpdate<Entity>(entityClassOrName: EntityTarget<Entity>, query: ObjectLiteral, update: Object, options?: FindOneAndReplaceOption): Promise<FindAndModifyWriteOpResultObject>;\n\n    /**\n     * Execute a geo search using a geo haystack index on a collection.\n     */\n    geoHaystackSearch<Entity>(entityClassOrName: EntityTarget<Entity>, x: number, y: number, options?: GeoHaystackSearchOptions): Promise<any>;\n\n    /**\n     * Execute the geoNear command to search for items in the collection.\n     */\n    geoNear<Entity>(entityClassOrName: EntityTarget<Entity>, x: number, y: number, options?: GeoNearOptions): Promise<any>;\n\n    /**\n     * Run a group command across a collection.\n     */\n    group<Entity>(entityClassOrName: EntityTarget<Entity>, keys: Object | Array<any> | Function | Code, condition: Object, initial: Object, reduce: Function | Code, finalize: Function | Code, command: boolean, options?: { readPreference?: ReadPreference | string }): Promise<any>;\n\n    /**\n     * Retrieve all the indexes on the collection.\n     */\n    collectionIndexes<Entity>(entityClassOrName: EntityTarget<Entity>): Promise<any>;\n\n    /**\n     * Retrieve all the indexes on the collection.\n     */\n    collectionIndexExists<Entity>(entityClassOrName: EntityTarget<Entity>, indexes: string | string[]): Promise<boolean>;\n\n    /**\n     * Retrieves this collections index info.\n     */\n    collectionIndexInformation<Entity>(entityClassOrName: EntityTarget<Entity>, options?: { full: boolean }): Promise<any>;\n\n    /**\n     * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n     */\n    initializeOrderedBulkOp<Entity>(entityClassOrName: EntityTarget<Entity>, options?: CollectionOptions): OrderedBulkOperation;\n\n    /**\n     * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n     */\n    initializeUnorderedBulkOp<Entity>(entityClassOrName: EntityTarget<Entity>, options?: CollectionOptions): UnorderedBulkOperation;\n\n    /**\n     * Inserts an array of documents into MongoDB.\n     */\n    insertMany<Entity>(entityClassOrName: EntityTarget<Entity>, docs: ObjectLiteral[], options?: CollectionInsertManyOptions): Promise<InsertWriteOpResult>;\n\n    /**\n     * Inserts a single document into MongoDB.\n     */\n    insertOne<Entity>(entityClassOrName: EntityTarget<Entity>, doc: ObjectLiteral, options?: CollectionInsertOneOptions): Promise<InsertOneWriteOpResult>;\n\n    /**\n     * Returns if the collection is a capped collection.\n     */\n    isCapped<Entity>(entityClassOrName: EntityTarget<Entity>): Promise<any>;\n\n    /**\n     * Get the list of all indexes information for the collection.\n     */\n    listCollectionIndexes<Entity>(entityClassOrName: EntityTarget<Entity>, options?: { batchSize?: number, readPreference?: ReadPreference | string }): CommandCursor;\n\n    /**\n     * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n     */\n    mapReduce<Entity>(entityClassOrName: EntityTarget<Entity>, map: Function | string, reduce: Function | string, options?: MapReduceOptions): Promise<any>;\n\n    /**\n     * Return N number of parallel cursors for a collection allowing parallel reading of entire collection.\n     * There are no ordering guarantees for returned results.\n     */\n    parallelCollectionScan<Entity>(entityClassOrName: EntityTarget<Entity>, options?: ParallelCollectionScanOptions): Promise<Cursor<Entity>[]>;\n\n    /**\n     * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n     */\n    reIndex<Entity>(entityClassOrName: EntityTarget<Entity>): Promise<any>;\n\n    /**\n     * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n     */\n    rename<Entity>(entityClassOrName: EntityTarget<Entity>, newName: string, options?: { dropTarget?: boolean }): Promise<Collection<any>>;\n\n    /**\n     * Replace a document on MongoDB.\n     */\n    replaceOne<Entity>(entityClassOrName: EntityTarget<Entity>, query: ObjectLiteral, doc: ObjectLiteral, options?: ReplaceOneOptions): Promise<UpdateWriteOpResult>;\n\n    /**\n     * Get all the collection statistics.\n     */\n    stats<Entity>(entityClassOrName: EntityTarget<Entity>, options?: { scale: number }): Promise<CollStats>;\n\n    watch<Entity>(entityClassOrName: EntityTarget<Entity>, pipeline?: Object[], options?: ChangeStreamOptions): ChangeStream;\n\n    /**\n     * Update multiple documents on MongoDB.\n     */\n    updateMany<Entity>(entityClassOrName: EntityTarget<Entity>, query: ObjectLiteral, update: ObjectLiteral, options?: { upsert?: boolean, w?: any, wtimeout?: number, j?: boolean }): Promise<UpdateWriteOpResult>;\n\n    /**\n     * Update a single document on MongoDB.\n     */\n    updateOne<Entity>(entityClassOrName: EntityTarget<Entity>, query: ObjectLiteral, update: ObjectLiteral, options?: ReplaceOneOptions): Promise<UpdateWriteOpResult>;\n\n};\n"],"sourceRoot":".."}